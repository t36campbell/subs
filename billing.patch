diff --git a/src/billing/billing.controller.ts b/src/billing/billing.controller.ts
new file mode 100644
index 0000000..065176b
--- /dev/null
+++ b/src/billing/billing.controller.ts
@@ -0,0 +1,97 @@
+import {
+  Controller,
+  Post,
+  Body,
+  Req,
+  UseGuards,
+  Headers,
+  RawBodyRequest,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import type { Request } from 'express';
+import { BillingService } from './billing.service';
+import { StripeService } from '../stripe/stripe.service';
+import { AuthGuard } from '@nestjs/passport';
+import { ConfigService } from '@nestjs/config';
+import { z } from 'zod';
+import { createZodDto } from 'nestjs-zod';
+
+// DTO for billing portal session creation
+const CreateBillingSessionSchema = z.object({
+  returnUrl: z.string().url(),
+});
+
+class CreateBillingSessionDto extends createZodDto(
+  CreateBillingSessionSchema,
+) {}
+
+@Controller('api/billing')
+export class BillingController {
+  constructor(
+    private billingService: BillingService,
+    private stripeService: StripeService,
+    private configService: ConfigService,
+  ) {}
+
+  @Post()
+  @UseGuards(AuthGuard('jwt'))
+  @HttpCode(HttpStatus.OK)
+  async createBillingSession(
+    @Body() body: CreateBillingSessionDto,
+    @Req() req: Request & { user: any },
+  ) {
+    // Extract user ID from authenticated request
+    const userId = req.user.sub || req.user.auth0Id || req.user.id;
+
+    if (!userId) {
+      throw new Error('User ID not found in authenticated request');
+    }
+
+    // Create billing portal session
+    const result = await this.billingService.createBillingPortalSession(
+      userId,
+      body.returnUrl,
+    );
+
+    return result;
+  }
+
+  @Post('webhook')
+  @HttpCode(HttpStatus.OK)
+  async handleWebhook(
+    @Headers('stripe-signature') signature: string,
+    @Req() req: Request & { rawBody?: Buffer },
+  ) {
+    if (!signature) {
+      throw new Error('Missing stripe-signature header');
+    }
+
+    const webhookSecret = this.configService.get<string>(
+      'STRIPE_WEBHOOK_SECRET',
+    );
+
+    if (!webhookSecret) {
+      throw new Error('STRIPE_WEBHOOK_SECRET not configured');
+    }
+
+    // Get raw body from request
+    const rawBody = req.rawBody;
+
+    if (!rawBody) {
+      throw new Error('Request body is required');
+    }
+
+    // Verify webhook signature and construct event
+    const event = await this.stripeService.constructWebhookEvent(
+      rawBody,
+      signature,
+      webhookSecret,
+    );
+
+    // Handle the event
+    await this.billingService.handleWebhookEvent(event);
+
+    return { received: true };
+  }
+}
diff --git a/src/billing/billing.module.ts b/src/billing/billing.module.ts
new file mode 100644
index 0000000..aaea406
--- /dev/null
+++ b/src/billing/billing.module.ts
@@ -0,0 +1,13 @@
+import { Module } from '@nestjs/common';
+import { BillingController } from './billing.controller';
+import { BillingService } from './billing.service';
+import { StripeModule } from '../stripe/stripe.module';
+import { PrismaModule } from '../prisma/prisma.module';
+
+@Module({
+  imports: [StripeModule, PrismaModule],
+  controllers: [BillingController],
+  providers: [BillingService],
+  exports: [BillingService],
+})
+export class BillingModule {}
diff --git a/src/billing/billing.service.ts b/src/billing/billing.service.ts
new file mode 100644
index 0000000..032663b
--- /dev/null
+++ b/src/billing/billing.service.ts
@@ -0,0 +1,322 @@
+import {
+  Injectable,
+  HttpException,
+  HttpStatus,
+  Logger,
+  ConflictException,
+} from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { PrismaService } from '../prisma/prisma.service';
+import { StripeService } from '../stripe/stripe.service';
+import Stripe from 'stripe';
+
+@Injectable()
+export class BillingService {
+  private readonly logger = new Logger(BillingService.name);
+  private readonly enforceMode: 'close' | 'reject';
+
+  constructor(
+    private prisma: PrismaService,
+    private stripeService: StripeService,
+    private configService: ConfigService,
+  ) {
+    // Configurable enforcement mode: 'close' or 'reject'
+    this.enforceMode = this.configService.get<'close' | 'reject'>(
+      'SUBSCRIPTION_ENFORCEMENT_MODE',
+      'close',
+    );
+  }
+
+  async createBillingPortalSession(userId: string, returnUrl: string) {
+    // Look up user
+    const user = await this.prisma.subscription.findUnique({
+      where: { auth0Id: userId },
+      include: {
+        subscriptions: {
+          where: { isActive: true },
+        },
+      },
+    });
+
+    if (!user) {
+      throw new HttpException('User not found', HttpStatus.NOT_FOUND);
+    }
+
+    // Get or create Stripe Customer ID
+    let stripeCustomerId = user.stripeCustomerId;
+
+    if (!stripeCustomerId) {
+      const customer = await this.stripeService.createCustomer(user.email, {
+        auth0Id: user.auth0Id,
+        firstName: user.firstName,
+        lastName: user.lastName,
+      });
+      stripeCustomerId = customer.id;
+
+      // Update user with Stripe Customer ID
+      await this.prisma.user.update({
+        where: { id: user.id },
+        data: { stripeCustomerId },
+      });
+    }
+
+    // Check active subscriptions count
+    const activeSubscriptions = user.subscriptions.filter(
+      (sub) => sub.isActive && sub.status === 'active',
+    );
+
+    if (activeSubscriptions.length > 1) {
+      this.logger.warn(
+        `User ${userId} has ${activeSubscriptions.length} active subscriptions`,
+      );
+      // This shouldn't happen, but log it if it does
+    }
+
+    // Create billing portal session
+    const session = await this.stripeService.createBillingPortalSession(
+      stripeCustomerId,
+      returnUrl,
+    );
+
+    return { url: session.url };
+  }
+
+  async handleWebhookEvent(event: Stripe.Event) {
+    this.logger.log(`Processing webhook event: ${event.type}`);
+
+    switch (event.type) {
+      case 'customer.subscription.created':
+        await this.handleSubscriptionCreated(
+          event.data.object as Stripe.Subscription,
+        );
+        break;
+      case 'customer.subscription.updated':
+        await this.handleSubscriptionUpdated(
+          event.data.object as Stripe.Subscription,
+        );
+        break;
+      case 'customer.subscription.deleted':
+        await this.handleSubscriptionDeleted(
+          event.data.object as Stripe.Subscription,
+        );
+        break;
+      default:
+        this.logger.log(`Unhandled event type: ${event.type}`);
+    }
+  }
+
+  private async handleSubscriptionCreated(subscription: Stripe.Subscription) {
+    const customerId = subscription.customer as string;
+
+    // Find user by Stripe Customer ID
+    const user = await this.prisma.user.findUnique({
+      where: { stripeCustomerId: customerId },
+      include: {
+        subscriptions: {
+          where: { isActive: true, status: 'active' },
+        },
+      },
+    });
+
+    if (!user) {
+      this.logger.error(
+        `User not found for customer ${customerId} during subscription creation`,
+      );
+      return;
+    }
+
+    // Check if user already has an active subscription
+    const activeSubscriptions = user.subscriptions.filter(
+      (sub) => sub.stripeSubscriptionId !== subscription.id,
+    );
+
+    if (activeSubscriptions.length > 0) {
+      if (this.enforceMode === 'reject') {
+        // Reject the new subscription
+        this.logger.error(
+          `User ${user.auth0Id} already has an active subscription. Rejecting new subscription ${subscription.id}`,
+        );
+        
+        // Cancel the new subscription
+        try {
+          await this.stripeService.cancelSubscription(subscription.id);
+        } catch (error) {
+          this.logger.error(
+            `Failed to cancel duplicate subscription ${subscription.id}: ${error.message}`,
+          );
+        }
+        
+        throw new ConflictException(
+          'User already has an active subscription',
+        );
+      } else {
+        // Close mode: deactivate existing subscriptions
+        this.logger.warn(
+          `User ${user.auth0Id} already has active subscriptions. Deactivating them.`,
+        );
+        
+        for (const oldSub of activeSubscriptions) {
+          await this.prisma.subscription.update({
+            where: { id: oldSub.id },
+            data: {
+              isActive: false,
+              status: 'replaced',
+            },
+          });
+          
+          // Optionally cancel on Stripe side as well
+          try {
+            await this.stripeService.cancelSubscription(
+              oldSub.stripeSubscriptionId,
+            );
+          } catch (error) {
+            this.logger.error(
+              `Failed to cancel old subscription ${oldSub.stripeSubscriptionId}: ${error.message}`,
+            );
+          }
+        }
+      }
+    }
+
+    // Create or update subscription record
+    const priceId =
+      subscription.items.data[0]?.price?.id || null;
+    const productId =
+      typeof subscription.items.data[0]?.price?.product === 'string'
+        ? subscription.items.data[0]?.price?.product
+        : subscription.items.data[0]?.price?.product?.id || null;
+
+    await this.prisma.subscription.upsert({
+      where: { stripeSubscriptionId: subscription.id },
+      update: {
+        status: subscription.status,
+        stripePriceId: priceId,
+        stripeProductId: productId,
+        currentPeriodStart: subscription.current_period_start
+          ? new Date(subscription.current_period_start * 1000)
+          : null,
+        currentPeriodEnd: subscription.current_period_end
+          ? new Date(subscription.current_period_end * 1000)
+          : null,
+        canceledAt: subscription.canceled_at
+          ? new Date(subscription.canceled_at * 1000)
+          : null,
+        cancelAt: subscription.cancel_at
+          ? new Date(subscription.cancel_at * 1000)
+          : null,
+        isActive: subscription.status === 'active',
+      },
+      create: {
+        userId: user.id,
+        stripeSubscriptionId: subscription.id,
+        stripeCustomerId: customerId,
+        status: subscription.status,
+        stripePriceId: priceId,
+        stripeProductId: productId,
+        currentPeriodStart: subscription.current_period_start
+          ? new Date(subscription.current_period_start * 1000)
+          : null,
+        currentPeriodEnd: subscription.current_period_end
+          ? new Date(subscription.current_period_end * 1000)
+          : null,
+        canceledAt: subscription.canceled_at
+          ? new Date(subscription.canceled_at * 1000)
+          : null,
+        cancelAt: subscription.cancel_at
+          ? new Date(subscription.cancel_at * 1000)
+          : null,
+        isActive: subscription.status === 'active',
+      },
+    });
+
+    this.logger.log(
+      `Subscription ${subscription.id} created for user ${user.auth0Id}`,
+    );
+  }
+
+  private async handleSubscriptionUpdated(subscription: Stripe.Subscription) {
+    const customerId = subscription.customer as string;
+
+    // Find user by Stripe Customer ID
+    const user = await this.prisma.user.findUnique({
+      where: { stripeCustomerId: customerId },
+    });
+
+    if (!user) {
+      this.logger.error(
+        `User not found for customer ${customerId} during subscription update`,
+      );
+      return;
+    }
+
+    // Update subscription record
+    const priceId = subscription.items.data[0]?.price?.id || null;
+    const productId =
+      typeof subscription.items.data[0]?.price?.product === 'string'
+        ? subscription.items.data[0]?.price?.product
+        : subscription.items.data[0]?.price?.product?.id || null;
+
+    await this.prisma.subscription.upsert({
+      where: { stripeSubscriptionId: subscription.id },
+      update: {
+        status: subscription.status,
+        stripePriceId: priceId,
+        stripeProductId: productId,
+        currentPeriodStart: subscription.current_period_start
+          ? new Date(subscription.current_period_start * 1000)
+          : null,
+        currentPeriodEnd: subscription.current_period_end
+          ? new Date(subscription.current_period_end * 1000)
+          : null,
+        canceledAt: subscription.canceled_at
+          ? new Date(subscription.canceled_at * 1000)
+          : null,
+        cancelAt: subscription.cancel_at
+          ? new Date(subscription.cancel_at * 1000)
+          : null,
+        isActive: subscription.status === 'active',
+      },
+      create: {
+        userId: user.id,
+        stripeSubscriptionId: subscription.id,
+        stripeCustomerId: customerId,
+        status: subscription.status,
+        stripePriceId: priceId,
+        stripeProductId: productId,
+        currentPeriodStart: subscription.current_period_start
+          ? new Date(subscription.current_period_start * 1000)
+          : null,
+        currentPeriodEnd: subscription.current_period_end
+          ? new Date(subscription.current_period_end * 1000)
+          : null,
+        canceledAt: subscription.canceled_at
+          ? new Date(subscription.canceled_at * 1000)
+          : null,
+        cancelAt: subscription.cancel_at
+          ? new Date(subscription.cancel_at * 1000)
+          : null,
+        isActive: subscription.status === 'active',
+      },
+    });
+
+    this.logger.log(
+      `Subscription ${subscription.id} updated for user ${user.auth0Id}`,
+    );
+  }
+
+  private async handleSubscriptionDeleted(subscription: Stripe.Subscription) {
+    // Mark subscription as inactive
+    await this.prisma.subscription.updateMany({
+      where: { stripeSubscriptionId: subscription.id },
+      data: {
+        status: subscription.status,
+        isActive: false,
+        canceledAt: subscription.canceled_at
+          ? new Date(subscription.canceled_at * 1000)
+          : new Date(),
+      },
+    });
+
+    this.logger.log(`Subscription ${subscription.id} deleted`);
+  }
+}
